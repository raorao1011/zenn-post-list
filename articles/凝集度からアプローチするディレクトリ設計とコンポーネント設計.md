---
title: "凝集度からアプローチするディレクトリ設計とコンポーネント設計"
emoji: "💪" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech"
topics: []
published: false
---

## はじめに

現代のソフトウェア開発において、開発者は驚くほど多くの時間をコードの理解に費やしています。Xia et al.（2018）の大規模なフィールド研究では、78名のプロフェッショナル開発者を対象とした3,148時間の作業時間分析により、**開発者は全作業時間の5## 参考文献

### 学術論文・研究資料
- Xia, X., Bao, L., Lo, D., Xing, Z., Li, S., & Hassan, A. E. (2018). "Measuring program comprehension: a large-scale field study with professionals." *IEEE Transactions on Software Engineering*, 44(10), 951-976.
- Minelli, R., Mocci, A., & Lanza, M. (2015). "I know what you did last summer--an investigation of how developers spend their time." *Proceedings of the 2015 IEEE 23rd international conference on program comprehension*, 25-35.
- Feitelson, D. G. (2023). "From code complexity metrics to program comprehension." *Communications of the ACM*, 66(5), 52-61.

### 技術記事・実践資料

https://qiita.com/uesho/items/59845b4891e12dfb3def#:~:text=%E5%87%9D%E9%9B%86%E5%BA%A6%E3%81%AE%E7%A8%AE%E9%A1%9E,%E8%A1%A8%E3%81%99%E3%81%93%E3%81%A8%E3%81%8C%E5%87%BA%E6%9D%A5%E3%81%BE%E3%81%99%E3%80%82&text=1%E3%81%8C%E6%9C%80%E3%82%82%E5%87%9D%E9%9B%86%E5%BA%A6,%E3%81%AA%E3%82%8A%E3%80%81%E4%BD%8E%E5%87%9D%E9%9B%86%E3%81%A8%E3%81%AA%E3%82%8B%E3%80%82

https://speakerdeck.com/noritakaikeda/ji-neng-de-ning-ji-nogai-nian-woyong-ite-fu-shu-ruru-lei-si-noji-neng-woduo-kuhan-musisutemuno-hurontoendonokonponentowoshi-qie-nifen-ge-suruグラム理解に費やしている**ことが明らかになりました。さらに、Minelli et al.（2015）の研究では、この割合は**最大70%に達する**と報告されています。

これらの研究が示すのは、現代の開発者にとって「コードを書く」ことよりも「コードを読み、理解する」ことの方がはるかに大きな負担となっているという現実です。実際に、Feitelson（2023）の研究では、開発者は編集作業にはわずか5%の時間しか割いていないのに対し、残りの大部分はコードの理解活動に費やされていることが示されています。

この現実を踏まえると、「理解しやすいコード」を書くことは、単なる美しいコードを書くことではなく、**開発チーム全体の生産性を左右する重要な要素**だと言えます。そして、コードの理解しやすさを大きく左右するのが「凝集度」という概念です。

凝集度の観点から設計されたコードは：
- **認知負荷を軽減**し、コードリーディング時間を短縮
- **変更の影響範囲を明確化**し、保守性を向上
- **チーム全体の開発効率を改善**

本記事では、フロントエンド開発における実践的な事例を通じて、凝集度を意識したディレクトリ設計とコンポーネント設計の手法を詳しく解説します。理論だけでなく、実際のプロジェクトで活用できる具体的なパターンとベストプラクティスを提示し、皆さんのチームの生産性向上に貢献できることを目指します。

## 凝集度とは何か

## 凝集度とは何か

### なぜ凝集度が重要なのか：研究が示すエビデンス

ソフトウェア工学における凝集度の重要性は、単なる理論的な美しさではありません。実際の開発現場における大規模な研究によって、その実用的価値が科学的に実証されています。

近年のプログラム理解に関する研究では、以下の驚くべき事実が明らかになっています：

**開発者の時間配分の現実**
- プログラム理解：58-70%
- コード編集：わずか5%
- その他（ナビゲーション、デバッグなど）：25-37%

この数字が示すのは、開発者の作業の大部分が「既存コードの理解」に費やされているという現実です。つまり、理解しやすいコードを書くことは、チーム全体の生産性に直結する重要な投資なのです。

**凝集度の低いコードがもたらす問題**
- コードの動作を理解するために複数のファイルを行き来する必要がある
- 変更の影響範囲が予測困難になる
- バグの原因特定に時間がかかる
- 新しいメンバーのオンボーディングが困難になる

### ソフトウェア工学における凝集度の定義
- 凝集度の基本概念
- 高凝集度と低凝集度の違い
- メンテナンス性・可読性への影響

### 凝集度の種類と特徴
- 偶然的凝集：関連性のない要素が偶然まとまっている状態
- 論理的凝集：似たような処理をまとめているが、実際の関係は薄い状態
- 時間的凝集：同じタイミングで実行される処理をまとめた状態
- 手順的凝集：処理の順序に基づいてまとめられた状態
- 連絡的凝集：同じデータを扱う処理がまとまっている状態
- 情報的凝集：同じデータ構造を操作する処理がまとまっている状態
- 機能的凝集：単一の明確な目的を持つ処理がまとまっている状態（理想的）

## 凝集度の具体例とフロントエンド開発への適用

### 低凝集度の例：偶然的凝集・論理的凝集
```typescript
// 悪い例：utils.ts（偶然的凝集）
export const formatDate = (date: Date) => { /* ... */ };
export const validateEmail = (email: string) => { /* ... */ };
export const calculateTax = (price: number) => { /* ... */ };
export const sortArray = (arr: any[]) => { /* ... */ };

// 悪い例：共通コンポーネント（論理的凝集）
const CommonModal = ({ type, data, onSubmit }) => {
  if (type === 'user') return <UserForm data={data} onSubmit={onSubmit} />;
  if (type === 'product') return <ProductForm data={data} onSubmit={onSubmit} />;
  if (type === 'order') return <OrderForm data={data} onSubmit={onSubmit} />;
  return null;
};
```

### 中程度の凝集度：時間的凝集・手順的凝集
```typescript
// 時間的凝集の例：初期化処理
const useAppInitialization = () => {
  useEffect(() => {
    // 同時に実行されるが、関連性は薄い
    loadUserSettings();
    initializeAnalytics();
    setupErrorHandling();
    preloadImages();
  }, []);
};

// 手順的凝集の例：フォーム処理
const useFormSubmission = () => {
  const handleSubmit = async (data) => {
    validateForm(data);        // ステップ1
    sanitizeInput(data);       // ステップ2
    submitToAPI(data);         // ステップ3
    showSuccessMessage();      // ステップ4
    redirectToNextPage();      // ステップ5
  };
};
```

### 高凝集度の例：情報的凝集・機能的凝集
```typescript
// 情報的凝集の例：ユーザー情報の操作
const useUserProfile = () => {
  const [user, setUser] = useState(null);
  
  const updateProfile = (profileData) => { /* ... */ };
  const changePassword = (passwordData) => { /* ... */ };
  const updateAvatar = (avatarFile) => { /* ... */ };
  const deleteAccount = () => { /* ... */ };
  
  return { user, updateProfile, changePassword, updateAvatar, deleteAccount };
};

// 機能的凝集の例：商品カート操作
const useShoppingCart = () => {
  const [items, setItems] = useState([]);
  
  const addItem = (product) => { /* 商品追加の単一責任 */ };
  const removeItem = (productId) => { /* 商品削除の単一責任 */ };
  const updateQuantity = (productId, quantity) => { /* 数量更新の単一責任 */ };
  const clearCart = () => { /* カートクリアの単一責任 */ };
  const getTotalPrice = () => { /* 合計計算の単一責任 */ };
  
  return { items, addItem, removeItem, updateQuantity, clearCart, getTotalPrice };
};
```

### React コンポーネントにおける凝集度の比較
```typescript
// 低凝集度：多くの責任を持つコンポーネント
const UserDashboard = () => {
  // ユーザー情報管理
  const [user, setUser] = useState(null);
  // 通知管理
  const [notifications, setNotifications] = useState([]);
  // テーマ管理
  const [theme, setTheme] = useState('light');
  // API呼び出し
  const fetchUserData = () => { /* ... */ };
  // 分析イベント送信
  const trackEvent = () => { /* ... */ };
  
  return (
    <div>
      {/* 複数の関心事が混在 */}
      <UserProfile user={user} />
      <NotificationList notifications={notifications} />
      <ThemeSelector theme={theme} onChange={setTheme} />
    </div>
  );
};

// 高凝集度：単一責任を持つコンポーネント
const UserProfile = ({ user }) => {
  // ユーザープロフィール表示のみに集中
  return (
    <Card>
      <Avatar src={user.avatar} />
      <Text>{user.name}</Text>
      <Text>{user.email}</Text>
    </Card>
  );
};

const NotificationCenter = ({ userId }) => {
  // 通知機能のみに集中
  const { notifications, markAsRead, clearAll } = useNotifications(userId);
  
  return (
    <VStack>
      {notifications.map(notification => (
        <NotificationItem 
          key={notification.id} 
          notification={notification} 
          onRead={markAsRead} 
        />
      ))}
    </VStack>
  );
};
```

## ディレクトリ設計における凝集度

### コードナビゲーションの隠れたコスト

Fritz and Murphy（2009）の研究では、開発者が1時間あたり平均25.7個の質問を頭に浮かべながらコードを読んでおり、それぞれの質問に答えるために複数のナビゲーション操作が必要だと報告されています。また、開発者は作業時間の47%を「システムの実装についての質問に答えるため」のコードナビゲーションに費やしているという驚くべき事実も明らかになっています。

この現実を踏まえると、ディレクトリ構成の設計は単なる「整理整頓」の問題ではありません。**開発者の認知負荷を軽減し、必要な情報に迅速にアクセスできるかどうかを左右する重要な設計判断**なのです。

### 従来のディレクトリ構成の問題点

**技術的分類による構成の限界**
```
src/
├── components/
│   ├── UserProfile.tsx
│   ├── ProductCard.tsx
│   ├── CartButton.tsx
│   └── OrderHistory.tsx
├── hooks/
│   ├── useUser.ts
│   ├── useProduct.ts
│   ├── useCart.ts
│   └── useOrder.ts
└── utils/
    ├── userHelpers.ts
    ├── productHelpers.ts
    ├── cartHelpers.ts
    └── orderHelpers.ts
```

この構成では、一つの機能を理解するために複数のディレクトリを行き来する必要があり、上述の研究が示すナビゲーションコストを増大させます：

- **認知的断片化**：関連する要素が物理的に分離されている
- **スケーラビリティの問題**：ファイル数の増加とともに探索コストが指数的に増大
- **変更影響の把握困難**：機能変更時に影響を受けるファイルの特定が困難

### 機能的凝集度に基づくディレクトリ設計

**Feature-basedアプローチの効果**
```
src/
├── features/
│   ├── user-management/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   └── types/
│   ├── product-catalog/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   └── types/
│   └── shopping-cart/
│       ├── components/
│       ├── hooks/
│       ├── services/
│       └── types/
├── shared/
└── app/
```

この構成により、研究で示されたナビゲーションコストを大幅に削減できます：

- **局所性の向上**：関連する要素が物理的に近接配置
- **予測可能性**：一貫した構造により必要なファイルの場所を予測可能
- **変更影響の明確化**：機能ごとの境界が明確で、影響範囲を容易に把握

### 実践例：ECサイトのディレクトリ構成
```
src/
├── features/
│   ├── auth/
│   ├── product/
│   ├── cart/
│   └── order/
├── shared/
└── app/
```

## Reactコンポーネント設計における凝集度

### コンポーネントの責任分離
- 単一責任の原則
- プレゼンテーションとロジックの分離
- カスタムフックの活用

### 高凝集度なコンポーネントの特徴
- 明確な責任範囲
- 適切な抽象化レベル
- 再利用可能性と保守性

## 実践的な設計パターン

### Atomic Designと凝集度の関係
- Atoms, Molecules, Organisms, Templates, Pages
- 各レベルでの凝集度の考え方
- 適切な粒度の見極め方

### カスタムフックによる状態管理の凝集化
- useProductDetail, useCartなどの実装例
- ビジネスロジックの集約
- テスタビリティの向上

### 共通コンポーネントの設計指針
- 汎用性と専用性のバランス
- プロパティ設計の考え方
- 拡張性を考慮した実装

## まとめ

### 凝集度を意識した設計がもたらす現実的なインパクト

本記事を通じて、凝集度の概念をフロントエンド開発に適用する具体的な手法を探ってきました。ここで改めて、この取り組みが開発現場にもたらす実際の価値を振り返ってみましょう。

**コードリーディング時間の大幅削減**
冒頭で紹介した研究結果の通り、開発者は作業時間の58〜70%をコードの理解に費やしています。機能的凝集度の高い設計により、この時間を大幅に短縮できます：

- **明確な責任範囲**により、コードの動作を迅速に把握可能
- **関連する要素の物理的な近接配置**により、探索時間を削減
- **一貫した抽象化レベル**により、認知負荷を軽減

**保守性の劇的な向上**
高凝集度の設計は、変更の影響範囲を明確化し、バグの発生率を下げます：

- 機能追加時の影響範囲が予測しやすい
- バグ修正時の副作用を最小限に抑制
- リファクタリング作業の安全性が向上

**開発効率の継続的改善**
チーム全体の生産性が向上し、長期的な開発速度が安定します：

- 新しいメンバーのオンボーディング時間短縮
- コードレビューの効率化
- 技術的負債の蓄積防止

### 実践への第一歩

凝集度を意識した設計を始めるために、以下の点から取り組むことをお勧めします：

1. **現在のコードベースの凝集度を評価**
   - 責任範囲が曖昧なコンポーネントを特定
   - 異なる関心事が混在している箇所をリストアップ

2. **小さな範囲からリファクタリング開始**
   - 新機能開発時に凝集度の原則を適用
   - 既存コードは段階的に改善

3. **チーム内での認識共有**
   - 凝集度の概念をチーム内で共有
   - コードレビュー時の観点として活用

開発者の時間の大部分がコードリーディングに費やされている現実を踏まえると、凝集度を意識した設計は単なる理論的な美しさを追求するものではありません。それは、**チーム全体の生産性を向上させ、より良いソフトウェアを効率的に開発するための実践的な手法**なのです。

皆さんの開発現場でも、この考え方を取り入れることで、より持続可能で効率的な開発体制を築いていけることを願っています。

## 参考文献

https://qiita.com/uesho/items/59845b4891e12dfb3def#:~:text=%E5%87%9D%E9%9B%86%E5%BA%A6%E3%81%AE%E7%A8%AE%E9%A1%9E,%E8%A1%A8%E3%81%99%E3%81%93%E3%81%A8%E3%81%8C%E5%87%BA%E6%9D%A5%E3%81%BE%E3%81%99%E3%80%82&text=1%E3%81%8C%E6%9C%80%E3%82%82%E5%87%9D%E9%9B%86%E5%BA%A6,%E3%81%AA%E3%82%8A%E3%80%81%E4%BD%8E%E5%87%9D%E9%9B%86%E3%81%A8%E3%81%AA%E3%82%8B%E3%80%82

https://speakerdeck.com/noritakaikeda/ji-neng-de-ning-ji-nogai-nian-woyong-ite-fu-shu-roru-lei-si-noji-neng-woduo-kuhan-musisutemuno-hurontoendonokonponentowoshi-qie-nifen-ge-suru
